<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gargantua: Relativistic Raytracer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            letter-spacing: 4px;
            z-index: 100;
            transition: opacity 1s;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            mix-blend-mode: screen;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 1.2rem;
            text-shadow: 0 0 10px #fff;
        }

        p {
            margin: 5px 0;
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .controls {
            margin-top: 15px;
            font-size: 0.75rem;
            color: #aaa;
            border-left: 2px solid #fff;
            padding-left: 10px;
        }

        /* Easter Egg Overlay */
        #frog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.8s ease-in;
        }

        #frog-overlay.active {
            display: flex;
            opacity: 1;
        }

        #frog-overlay img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            animation: frogPulse 2s ease-in-out infinite;
        }

        @keyframes frogPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.03);
            }
        }

        #frog-overlay .dismiss-text {
            position: absolute;
            bottom: 30px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        /* Rickroll Video Overlay */
        #rickroll-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 10000;
            display: none;
            background: #000;
        }
    </style>
</head>

<body>
    <div id="loading">GENERATING GALACTIC BACKGROUND...</div>
    <div id="ui">
        <h1>Gargantua Simulation</h1>
        <p>Real-time Raymarching / Gravitational Lensing</p>
        <div class="controls">
            DRAG / 1-Finger Swipe to Orbit<br>
            SCROLL / Pinch to Zoom<br>
            WASD to Move<br>
            SPACE / SHIFT for Up / Down<br>
            Double Click / Double Tap to Reset
        </div>
    </div>

    <!-- Easter Egg -->
    <div id="frog-overlay" onclick="dismissFrog()">
        <img src="frog.png" alt="You found the frog!">
        <span class="dismiss-text">Click anywhere to escape the void</span>
    </div>

    <!-- Rickroll Video -->
    <video id="rickroll-video" src="Rick_Roll_Different_link_no_ads_360p.mp4" playsinline></video>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", stencil: false, depth: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // --- Interaction State ---
        let theta = 0;
        let phi = Math.PI * 0.4;
        let radius = 18.0;
        const camPos = new THREE.Vector3();
        const camTarget = new THREE.Vector3(0, 0, 0);

        // --- Procedural FBM Noise Texture for Smooth Disk ---
        function createNoiseTexture() {
            const size = 512;
            const data = new Uint8Array(size * size * 4);

            // Permutation table for smooth noise
            const p = new Uint8Array(512);
            for (let i = 0; i < 256; i++) p[i] = Math.floor(Math.random() * 256);
            for (let i = 256; i < 512; i++) p[i] = p[i - 256];

            function hash(x, y) { return p[(x & 255) + p[y & 255]]; }
            function smoothNoise(x, y, wrapBase) {
                const ix = Math.floor(x), iy = Math.floor(y);
                const fx = x - ix, fy = y - iy;
                const ux = fx * fx * (3 - 2 * fx), uy = fy * fy * (3 - 2 * fy);

                const x0 = ix % wrapBase, x1 = (ix + 1) % wrapBase;
                const y0 = iy % wrapBase, y1 = (iy + 1) % wrapBase;

                const n00 = hash(x0, y0) / 255.0, n10 = hash(x1, y0) / 255.0;
                const n01 = hash(x0, y1) / 255.0, n11 = hash(x1, y1) / 255.0;
                const nx0 = n00 * (1 - ux) + n10 * ux;
                const nx1 = n01 * (1 - ux) + n11 * ux;
                return nx0 * (1 - uy) + nx1 * uy;
            }

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const nx = (x / size) * 8.0;
                    const ny = (y / size) * 8.0;

                    let val = smoothNoise(nx * 2, ny * 2, 16) * 0.5 +
                        smoothNoise(nx * 6, ny * 6, 48) * 0.25 +
                        smoothNoise(nx * 12, ny * 12, 96) * 0.125 +
                        smoothNoise(nx * 24, ny * 24, 192) * 0.0625;

                    let v = Math.min(255, Math.max(0, Math.floor(val * 220)));
                    const i = (y * size + x) * 4;
                    data[i] = v; data[i + 1] = v; data[i + 2] = v; data[i + 3] = 255;
                }
            }
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.generateMipmaps = true;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.minFilter = THREE.LinearMipMapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.needsUpdate = true;
            return texture;
        }
        const noiseTex = createNoiseTexture();

        // --- Randomly Generated Interstellar Background ---
        function drawNebulae({ ctx, width, height, rng, galacticWave, themeBias }) {
            // --- 1. Sparse Nebula Patches (few, faint, themed) ---
            ctx.globalCompositeOperation = 'screen';
            const nebulaCount = 15 + Math.floor(rng() * 20);
            for (let i = 0; i < nebulaCount; i++) {
                const x = rng() * width;
                // Nebulae cluster somewhat near the galactic plane
                const nearBand = rng() < 0.6;
                const y = nearBand ? galacticWave(x) + (rng() - 0.5) * 400 : rng() * height;
                const r = 100 + rng() * 500;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                const warmth = rng();
                let h, s, l;
                if (themeBias < 0.33) {
                    // Warm amber theme
                    if (warmth < 0.6) { h = 20 + rng() * 25; s = 25 + rng() * 15; l = 4 + rng() * 4; }
                    else if (warmth < 0.85) { h = 35 + rng() * 15; s = 20; l = 3 + rng() * 3; }
                    else { h = 200 + rng() * 40; s = 15; l = 3; }
                } else if (themeBias < 0.66) {
                    // Cool blue theme
                    if (warmth < 0.6) { h = 210 + rng() * 40; s = 20 + rng() * 15; l = 3 + rng() * 4; }
                    else if (warmth < 0.85) { h = 250 + rng() * 20; s = 15; l = 3 + rng() * 3; }
                    else { h = 25 + rng() * 20; s = 20; l = 3; }
                } else {
                    // Mixed theme
                    if (warmth < 0.4) { h = 25 + rng() * 20; s = 25; l = 4 + rng() * 3; }
                    else if (warmth < 0.7) { h = 220 + rng() * 30; s = 20; l = 3 + rng() * 3; }
                    else { h = 35 + rng() * 10; s = 20; l = 4; }
                }
                const alpha = 0.003 + rng() * 0.007;
                grad.addColorStop(0, `hsla(${h}, ${s}%, ${l}%, ${alpha})`);
                grad.addColorStop(0.5, `hsla(${h}, ${s}%, ${l * 0.3}%, ${alpha * 0.2})`);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }
        }

        function drawGalacticBand({ ctx, width, height, rng, galacticWave }) {
            // --- 2. Subtle Galactic Band (varies per generation) ---
            ctx.globalCompositeOperation = 'screen';
            const bandDensity = 200 + Math.floor(rng() * 200);
            for (let i = 0; i < bandDensity; i++) {
                const x = rng() * width;
                const waveY = galacticWave(x);
                const u1 = Math.max(0.0001, rng());
                const v1 = rng();
                const gauss = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * v1);
                const spread = gauss * (90 + rng() * 60);
                const y = waveY + spread;

                if (y < -50 || y > height + 50) continue;

                const r = 20 + rng() * 120;
                const grad = ctx.createRadialGradient(x, y, 0, x, y, r);

                const bandType = rng();
                let h, s, l;
                if (bandType < 0.4) { h = 30 + rng() * 15; s = 25 + rng() * 10; l = 6 + rng() * 4; }
                else if (bandType < 0.65) { h = 15 + rng() * 15; s = 30; l = 5 + rng() * 3; }
                else if (bandType < 0.85) { h = 220 + rng() * 20; s = 18; l = 5 + rng() * 3; }
                else { h = 40 + rng() * 10; s = 18; l = 6 + rng() * 3; }
                const alpha = 0.003 + rng() * 0.008;

                grad.addColorStop(0, `hsla(${h}, ${s}%, ${l}%, ${alpha})`);
                grad.addColorStop(0.5, `hsla(${h}, ${s}%, ${l * 0.3}%, ${alpha * 0.3})`);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }
        }

        function drawDustWisps({ ctx, width, rng, galacticWave }) {
            // --- 3. Filamentary Dust Wisps (sparse, elongated structures) ---
            ctx.globalCompositeOperation = 'screen';
            for (let i = 0; i < 60; i++) {
                const x = rng() * width;
                const waveY = galacticWave(x);
                const u1 = Math.max(0.0001, rng());
                const v1 = rng();
                const gauss = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * v1);
                const y = waveY + gauss * 100;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rng() * Math.PI * 0.4 - 0.2);
                ctx.scale(2.0 + rng() * 4.0, 0.3 + rng() * 0.5);

                const r = 20 + rng() * 60;
                const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                const h = 25 + rng() * 25;
                const alpha = 0.004 + rng() * 0.006;
                grad.addColorStop(0, `hsla(${h}, 30%, 12%, ${alpha})`);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }

        function drawDarkDustLanes({ ctx, width, rng, galacticWave }) {
            // --- 4. Dark Dust Lanes / Absorption Nebulae ---
            ctx.globalCompositeOperation = 'multiply';
            for (let i = 0; i < 400; i++) {
                const x = rng() * width;
                const waveY = galacticWave(x);
                const u1 = Math.max(0.0001, rng());
                const v1 = rng();
                const gauss = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * v1);
                const y = waveY + gauss * 80;
                const r = 15 + rng() * 100;

                // Elongated dark streaks
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rng() * 0.6 - 0.3);
                ctx.scale(1.0 + rng() * 3.0, 0.5 + rng() * 0.5);

                const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                const darkness = 0.4 + rng() * 0.4;
                grad.addColorStop(0, `rgba(0,0,0,${darkness})`);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }

        function drawDistantGalaxies({ ctx, width, height, rng }) {
            // --- 5. Distant Galaxy Patches (small concentrated glows) ---
            ctx.globalCompositeOperation = 'screen';
            const galaxyCount = 8 + Math.floor(rng() * 15);
            for (let i = 0; i < galaxyCount; i++) {
                const x = rng() * width;
                const y = rng() * height;
                const r = 4 + rng() * 12;

                // Tiny bright galaxy cores
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rng() * Math.PI);
                ctx.scale(1.0 + rng() * 2.0, 0.4 + rng() * 0.6);
                const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                grad.addColorStop(0, `rgba(255,240,210,0.25)`);
                grad.addColorStop(0.3, `rgba(255,200,150,0.08)`);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }

        function drawStarLayer({ ctx, width, height, rng, galacticWave, count, sizeMult, alphaMult, galacticBias }) {
            for (let i = 0; i < count; i++) {
                const x = rng() * width;
                let y = rng() * height;

                // Bias stars toward galactic plane
                if (rng() < galacticBias) {
                    const waveY = galacticWave(x);
                    const u1 = Math.max(0.0001, rng());
                    const v1 = rng();
                    const gauss = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * v1);
                    y = waveY + (gauss * 200);
                }

                if (y < 0) y += height;
                if (y > height) y -= height;

                const r = rng() * sizeMult + 0.2;
                const alpha = (rng() * 0.6 + 0.4) * alphaMult;

                // Star spectral types — weighted toward the cool white/blue-white of Interstellar
                let rC = 255, gC = 255, bC = 255;
                const t = rng();
                if (t < 0.05) { rC = 140; gC = 170; bC = 255; }         // O/B — Hot Blue
                else if (t < 0.2) { rC = 180; gC = 210; bC = 255; }     // B/A — Blue-White
                else if (t < 0.55) { rC = 255; gC = 252; bC = 248; }    // F/G — Warm White
                else if (t < 0.75) { rC = 255; gC = 235; bC = 200; }    // G/K — Pale Yellow
                else if (t < 0.9) { rC = 255; gC = 200; bC = 150; }     // K — Orange
                else { rC = 255; gC = 160; bC = 120; }                   // M — Red Dwarf

                ctx.fillStyle = `rgba(${rC},${gC},${bC},${alpha})`;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();

                // Soft halo for medium-bright stars
                if (r > 0.9 && alpha > 0.5) {
                    const grad = ctx.createRadialGradient(x, y, 0, x, y, r * 3.5);
                    grad.addColorStop(0, `rgba(${rC},${gC},${bC},${alpha * 0.25})`);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(x, y, r * 3.5, 0, Math.PI * 2); ctx.fill();
                }
            }
        }

        function drawStarfield(env) {
            // --- 6. Dense Starfield ---
            env.ctx.globalCompositeOperation = 'source-over';

            // Layer 1: Dense tiny background stars (the "powder")
            drawStarLayer({ ...env, count: 25000, sizeMult: 0.5, alphaMult: 0.35, galacticBias: 0.6 });
            // Layer 2: Medium background stars
            drawStarLayer({ ...env, count: 6000, sizeMult: 0.9, alphaMult: 0.55, galacticBias: 0.65 });
            // Layer 3: Visible stars
            drawStarLayer({ ...env, count: 2000, sizeMult: 1.4, alphaMult: 0.75, galacticBias: 0.5 });
            // Layer 4: Bright prominent stars
            drawStarLayer({ ...env, count: 300, sizeMult: 2.0, alphaMult: 0.95, galacticBias: 0.3 });
        }

        function drawDiffractionSpikes({ ctx, width, height, rng, galacticWave }) {
            // --- 7. Diffraction Spikes on Brightest Stars ---
            ctx.globalCompositeOperation = 'screen';
            const spikeCount = 40 + Math.floor(rng() * 40);
            for (let i = 0; i < spikeCount; i++) {
                const x = rng() * width;
                let y = rng() * height;
                // Some cluster near galactic plane
                if (rng() < 0.4) {
                    const waveY = galacticWave(x);
                    y = waveY + (rng() - 0.5) * 300;
                }
                if (y < 0) y += height;
                if (y > height) y -= height;

                const brightness = 0.4 + rng() * 0.6;
                const spikeLen = 8 + rng() * 25;

                // Star spectral color for this bright star
                const t = rng();
                let rC, gC, bC;
                if (t < 0.3) { rC = 200; gC = 220; bC = 255; }       // Blue-white
                else if (t < 0.7) { rC = 255; gC = 250; bC = 240; }  // Warm white
                else { rC = 255; gC = 220; bC = 180; }                 // Yellow

                // Core glow
                const coreR = 2.0 + rng() * 2.0;
                const cGrad = ctx.createRadialGradient(x, y, 0, x, y, coreR * 5);
                cGrad.addColorStop(0, `rgba(${rC},${gC},${bC},${brightness})`);
                cGrad.addColorStop(0.2, `rgba(${rC},${gC},${bC},${brightness * 0.4})`);
                cGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = cGrad;
                ctx.beginPath(); ctx.arc(x, y, coreR * 5, 0, Math.PI * 2); ctx.fill();

                // 4-point diffraction spikes (cross pattern)
                ctx.strokeStyle = `rgba(${rC},${gC},${bC},${brightness * 0.35})`;
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                // Horizontal spike
                ctx.moveTo(x - spikeLen, y); ctx.lineTo(x + spikeLen, y);
                // Vertical spike
                ctx.moveTo(x, y - spikeLen); ctx.lineTo(x, y + spikeLen);
                ctx.stroke();

                // Thinner secondary diagonal spikes (rotated 45°)
                if (rng() > 0.5) {
                    const dLen = spikeLen * 0.5;
                    ctx.strokeStyle = `rgba(${rC},${gC},${bC},${brightness * 0.15})`;
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x - dLen * 0.707, y - dLen * 0.707);
                    ctx.lineTo(x + dLen * 0.707, y + dLen * 0.707);
                    ctx.moveTo(x + dLen * 0.707, y - dLen * 0.707);
                    ctx.lineTo(x - dLen * 0.707, y + dLen * 0.707);
                    ctx.stroke();
                }
            }
        }

        function drawStarClusters({ ctx, width, height, rng }) {
            // --- 8. Faint Star Clusters (globular cluster patches) ---
            ctx.globalCompositeOperation = 'screen';
            const clusterCount = 5 + Math.floor(rng() * 8);
            for (let c = 0; c < clusterCount; c++) {
                const cx = rng() * width;
                const cy = rng() * height;
                const clusterSize = 30 + rng() * 60;
                const starCount = 80 + Math.floor(rng() * 150);

                for (let i = 0; i < starCount; i++) {
                    const u1 = Math.max(0.0001, rng());
                    const v1 = rng();
                    const gauss = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * v1);
                    const sx = cx + gauss * clusterSize * 0.5;
                    const sy = cy + (Math.sqrt(-2 * Math.log(Math.max(0.0001, rng()))) * Math.cos(2 * Math.PI * rng())) * clusterSize * 0.5;

                    const r = 0.3 + rng() * 0.6;
                    const alpha = 0.2 + rng() * 0.4;
                    ctx.fillStyle = `rgba(255,248,235,${alpha})`;
                    ctx.beginPath(); ctx.arc(sx, sy, r, 0, Math.PI * 2); ctx.fill();
                }

                // Overall cluster glow
                const gGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, clusterSize);
                gGrad.addColorStop(0, `rgba(255,240,210,0.04)`);
                gGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gGrad;
                ctx.beginPath(); ctx.arc(cx, cy, clusterSize, 0, Math.PI * 2); ctx.fill();
            }
        }

        function createGalacticBackground() {
            const width = 4096;
            const height = 2048;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d', { alpha: false });

            // Use Math.random for unique generation each load
            const rng = Math.random;

            // Randomized galactic band parameters — different each load
            const bandPhase = rng() * Math.PI * 2;        // Random phase offset
            const bandFreq = 1.2 + rng() * 0.8;           // Frequency variation
            const bandAmp = 120 + rng() * 120;             // Amplitude variation
            const bandTilt = (rng() - 0.5) * 0.3;          // Slight vertical offset
            const bandCenter = height / 2 + bandTilt * height;

            // Random color theme bias — picks a dominant nebula mood
            const themeBias = rng();  // 0-0.33: warm amber, 0.33-0.66: cool blue, 0.66-1: mixed

            function galacticWave(x) {
                const wave1 = Math.sin((x / width) * Math.PI * bandFreq + bandPhase) * bandAmp;
                const wave2 = Math.sin((x / width) * Math.PI * (bandFreq * 2.5) + bandPhase * 1.7) * (bandAmp * 0.2);
                return bandCenter + wave1 + wave2;
            }

            // Deep void base — pure black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);

            const env = { ctx, width, height, rng, galacticWave, themeBias };

            drawNebulae(env);
            drawGalacticBand(env);
            drawDustWisps(env);
            drawDarkDustLanes(env);
            drawDistantGalaxies(env);
            drawStarfield(env);
            drawDiffractionSpikes(env);
            drawStarClusters(env);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.ClampToEdgeWrapping;
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            return tex;
        }
        const starTex = createGalacticBackground();

        // --- The Shader Material ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                iTime: { value: 0 },
                camPos: { value: new THREE.Vector3() },
                camDir: { value: new THREE.Vector3() },
                camUp: { value: new THREE.Vector3() },
                camRight: { value: new THREE.Vector3() },
                noiseTex: { value: noiseTex },
                starTex: { value: starTex }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec3 camPos;
                uniform vec3 camDir;
                uniform vec3 camUp;
                uniform vec3 camRight;
                uniform sampler2D noiseTex;
                uniform sampler2D starTex;
                varying vec2 vUv;

                #define MAX_STEPS 400
                #define HIT_THRESHOLD 0.05
                #define BH_RADIUS 2.0
                #define PHOTON_SPHERE 3.0
                #define DISK_INNER 5.0
                #define DISK_OUTER 28.0
                #define GRAVITY_STRENGTH 2.4
                #define ESCAPE_DIST 100.0

                // Disk Texture Logic — Interstellar warm palette
                vec3 getDiskColor(vec3 pos, float dist) {
                    float r = length(pos);
                    if(r < DISK_INNER || r > DISK_OUTER) return vec3(0.0);
                    
                    float angle = atan(pos.z, pos.x);
                    float speed = 3.0 * pow(r, -1.5); 
                    float rotAngle = angle + iTime * speed;
                    
                    // UV for noise sampling (all multipliers are integers for seamless tiling)
                    vec2 uv = vec2(r * 0.08, (rotAngle / 6.2831853) * 3.0);
                    float noise1 = texture2D(noiseTex, uv).r;
                    float noise2 = texture2D(noiseTex, vec2(uv.x * 2.0, uv.y * 2.0) + vec2(iTime*0.08)).g;
                    float noise3 = texture2D(noiseTex, vec2(uv.x * 1.0, uv.y * 3.0) + vec2(iTime*0.03, 0.5)).b;
                    
                    // Multiplicative turbulence — smooth variation without hard holes
                    float turbulence = mix(0.6, 1.0, noise3);
                    float intensity = noise1 * noise2 * turbulence * 2.2;
                    
                    // Radial alpha falloff — wider and softer
                    float alpha = smoothstep(DISK_INNER, DISK_INNER + 0.8, r) * (1.0 - smoothstep(DISK_OUTER - 3.0, DISK_OUTER, r));
                    
                    // Temperature gradient: white-hot inner → amber → deep orange outer
                    float temp = 1.0 - smoothstep(DISK_INNER, DISK_OUTER * 0.5, r);
                    vec3 hotWhite = vec3(1.0, 0.98, 0.9);
                    vec3 warmGold = vec3(1.0, 0.7, 0.3);
                    vec3 deepOrange = vec3(0.8, 0.25, 0.05);
                    vec3 col = mix(deepOrange, warmGold, temp);
                    col = mix(col, hotWhite, temp * temp);
                    
                    // Subtle purple/violet tint at mid-range radii
                    float midRange = smoothstep(DISK_INNER + 1.0, DISK_INNER + 3.0, r) * (1.0 - smoothstep(DISK_OUTER * 0.5, DISK_OUTER * 0.7, r));
                    vec3 purple = vec3(0.6, 0.2, 0.8);
                    col = mix(col, purple, midRange * 0.15);
                    
                    // Doppler beaming — affects brightness only, not hue
                    vec3 vel = normalize(vec3(-pos.z, 0.0, pos.x));
                    vec3 viewDir = normalize(pos - camPos);
                    float doppler = dot(vel, viewDir);
                    float beam = pow(1.0 + doppler * 0.55, 3.5);
                    
                    // Inner edge extra brightness
                    float innerBoost = 1.0 + smoothstep(DISK_INNER + 1.5, DISK_INNER, r) * 3.0;
                    
                    return col * intensity * alpha * beam * innerBoost;
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    
                    vec3 ro = camPos;
                    vec3 rd = normalize(camDir + uv.x * camRight + uv.y * camUp);
                    
                    vec3 p = ro;
                    vec3 v = rd; 
                    vec3 col = vec3(0.0);
                    
                    float dt = 0.1; 
                    float totalDist = 0.0;
                    
                    vec3 accColor = vec3(0.0);
                    float accAlpha = 0.0;
                    
                    for(int i = 0; i < MAX_STEPS; i++) {
                        float r = length(p);
                        
                        // 1. Event Horizon Hit
                        if(r < BH_RADIUS) {
                            col = vec3(0.0);
                            break;
                        }
                        
                        // 2. Escape Condition (Sample Galaxy)
                        if(r > ESCAPE_DIST) {
                            // Tilt the galaxy for a better composition angle
                            vec3 bgV = v;
                            
                            // Rotate around X
                            float rotX = 0.6; 
                            mat2 rX = mat2(cos(rotX), -sin(rotX), sin(rotX), cos(rotX));
                            bgV.yz = rX * bgV.yz;
                            
                            // Rotate around Y
                            float rotY = 1.1; 
                            mat2 rY = mat2(cos(rotY), -sin(rotY), sin(rotY), cos(rotY));
                            bgV.xz = rY * bgV.xz;

                            float phi = atan(bgV.z, bgV.x);
                            float theta = acos(bgV.y);
                            vec2 starUV = vec2(phi / 6.2831 + 0.5, theta / 3.14159);
                            vec3 stars = texture2D(starTex, starUV).rgb;
                            col = stars; 
                            break;
                        }
                        
                        // Schwarzschild-like geodesic for photons
                        // GR correction term scales as 1/r^4 (compared to Newtonian 1/r^3)
                        float r2 = r * r;
                        vec3 acc = -p * (GRAVITY_STRENGTH / (r2 * r2)); // ~1/r^4 gives proper photon sphere
                        
                        // 3. Accretion Disk Intersection (Plane Y=0)
                        float nextY = p.y + v.y * dt;
                        if(p.y * nextY < 0.0) {
                            float t_hit = -p.y / v.y;
                            vec3 hitPos = p + v * t_hit;
                            vec3 diskC = getDiskColor(hitPos, length(hitPos));
                            accColor += diskC * 1.2;
                        }
                        
                        // Photon ring: thin, crisp bright white outline
                        float photonDist = abs(r - PHOTON_SPHERE);
                        if(photonDist < 0.3) {
                            float ringGlow = exp(-photonDist * 30.0) * 2.5 * dt * exp(-abs(p.y) * 12.0);
                            accColor += vec3(1.0, 0.95, 0.85) * ringGlow;
                        }
                        
                        // Leapfrog integration
                        v += acc * dt;
                        v = normalize(v);
                        p += v * dt;
                        
                        // Adaptive step: very fine near photon sphere, coarser far away
                        if(r < 3.0) {
                            dt = max(0.005, (r - BH_RADIUS) * 0.03);
                        } else if(r < 10.0) {
                            dt = r * 0.025;
                        } else {
                            dt = r * 0.06;
                        } 
                    }
                    
                    col += accColor;
                    gl_FragColor = vec4(col, 1.0);
                }
            `
        });

        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(quad);

        // --- Post Processing (Bloom) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.08;
        bloomPass.strength = 1.0;
        bloomPass.radius = 0.7;
        composer.addPass(bloomPass);

        // --- Input Handling ---
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        const keysPressed = new Set();
        const MOVE_SPEED = 0.15;
        let frogTriggered = false;

        // Easter Egg dismiss function (global scope for onclick)
        window.dismissFrog = function () {
            const overlay = document.getElementById('frog-overlay');
            overlay.classList.remove('active');
            setTimeout(() => overlay.style.display = 'none', 800);
            // Reset camera to safe distance
            camTarget.set(0, 0, 0);
            radius = 18.0;
            theta = 0;
            phi = Math.PI * 0.4;
            frogTriggered = false;
        };

        const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        let konamiIndex = 0;

        window.addEventListener('keydown', (e) => {
            keysPressed.add(e.code);
            // Konami code check
            if (e.code === konamiCode[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiCode.length) {
                    const video = document.getElementById('rickroll-video');
                    video.style.display = 'block';
                    video.play().catch(err => console.error("Video play failed:", err));
                    if (video.requestFullscreen) {
                        video.requestFullscreen().catch(err => console.error("Fullscreen failed:", err));
                    }
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
        });
        window.addEventListener('keyup', (e) => keysPressed.delete(e.code));

        window.addEventListener('mousedown', (e) => {
            isDragging = true;
            prevMouse.x = e.clientX;
            prevMouse.y = e.clientY;
        });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = (e.clientX - prevMouse.x) * 0.005;
                const dy = (e.clientY - prevMouse.y) * 0.005;
                theta -= dx;
                phi -= dy;
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                prevMouse.x = e.clientX;
                prevMouse.y = e.clientY;
            }
        });
        window.addEventListener('wheel', (e) => {
            radius += e.deltaY * 0.01;
            radius = Math.max(3.0, Math.min(60.0, radius));
        });
        window.addEventListener('dblclick', () => {
            radius = 18.0; theta = 0; phi = Math.PI * 0.4;
            camTarget.set(0, 0, 0);
        });

        // --- Touch Handling (Mobile Support) ---
        let lastTouchTime = 0;
        let prevTouchPinchDist = 0;

        window.addEventListener('touchstart', (e) => {
            // Prevent default behavior (like zooming or scrolling the page)
            if (e.cancelable) e.preventDefault();

            if (e.touches.length === 1) {
                isDragging = true;
                prevMouse.x = e.touches[0].clientX;
                prevMouse.y = e.touches[0].clientY;

                // Double tap check
                const now = Date.now();
                if (now - lastTouchTime < 300) {
                    radius = 18.0; theta = 0; phi = Math.PI * 0.4;
                    camTarget.set(0, 0, 0);
                    lastTouchTime = 0;
                } else {
                    lastTouchTime = now;
                }
            } else if (e.touches.length === 2) {
                isDragging = false; // Disable orbit when zooming
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                prevTouchPinchDist = Math.hypot(dx, dy);
            }
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (e.cancelable) e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                const dx = (e.touches[0].clientX - prevMouse.x) * 0.005;
                const dy = (e.touches[0].clientY - prevMouse.y) * 0.005;
                theta -= dx;
                phi -= dy;
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                prevMouse.x = e.touches[0].clientX;
                prevMouse.y = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.hypot(dx, dy);

                const delta = prevTouchPinchDist - dist; // If distance decreases (pinch in), radius increases (zoom out)
                radius += delta * 0.1;
                radius = Math.max(3.0, Math.min(60.0, radius));

                prevTouchPinchDist = dist;
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isDragging = false;
            } else if (e.touches.length === 1) {
                // If one finger lifts during a pinch, resume dragging with the remaining finger
                isDragging = true;
                prevMouse.x = e.touches[0].clientX;
                prevMouse.y = e.touches[0].clientY;
            }
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        const loadingEl = document.getElementById('loading');
        // Small timeout to ensure texture renders to canvas
        setTimeout(() => loadingEl.style.opacity = 0, 800);
        setTimeout(() => loadingEl.style.display = 'none', 1800);

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Compute camera orbit position relative to target
            camPos.set(
                camTarget.x + radius * Math.sin(phi) * Math.sin(theta),
                camTarget.y + radius * Math.cos(phi),
                camTarget.z + radius * Math.sin(phi) * Math.cos(theta)
            );

            const forward = new THREE.Vector3().subVectors(camTarget, camPos).normalize();
            const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();
            const up = new THREE.Vector3().crossVectors(forward, right).normalize();

            // --- WASD + Space/Shift Movement ---
            if (keysPressed.has('KeyW')) camTarget.addScaledVector(forward, MOVE_SPEED);
            if (keysPressed.has('KeyS')) camTarget.addScaledVector(forward, -MOVE_SPEED);
            if (keysPressed.has('KeyA')) camTarget.addScaledVector(right, -MOVE_SPEED);
            if (keysPressed.has('KeyD')) camTarget.addScaledVector(right, MOVE_SPEED);
            if (keysPressed.has('Space')) camTarget.y += MOVE_SPEED;
            if (keysPressed.has('ShiftLeft') || keysPressed.has('ShiftRight')) camTarget.y -= MOVE_SPEED;

            // --- Easter Egg: Frog when entering the event horizon ---
            const distToBlackHole = camPos.length();
            if (distToBlackHole < 2.5 && !frogTriggered) {
                frogTriggered = true;
                const overlay = document.getElementById('frog-overlay');
                overlay.style.display = 'flex';
                requestAnimationFrame(() => overlay.classList.add('active'));
            }

            material.uniforms.iTime.value = time;
            material.uniforms.camPos.value.copy(camPos);
            material.uniforms.camDir.value.copy(forward);
            material.uniforms.camUp.value.copy(up);
            material.uniforms.camRight.value.copy(right);

            composer.render();
        }

        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            renderer.setSize(w, h);
            composer.setSize(w, h);
            material.uniforms.iResolution.value.set(w, h);
        });

        animate();
    </script>
</body>

</html>